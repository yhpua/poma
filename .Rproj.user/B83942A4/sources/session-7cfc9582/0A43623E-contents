
rm(list=ls())
library(rms)
# suppressPackageStartupMessages(library("tidyverse"))
# library(Brobdingnag) ## if tidyverse fails to load
library(tidyverse)
library(stringi)
library(glue)
library(janitor)
library(data.table)
library(tidymodels)
library(tictoc)
library(fuzzyjoin)
library(rlang)  ## masks purrr::flatten()
library(stringr)

## set working directory
aa <- rstudioapi::getActiveDocumentContext()$path
setwd(str_remove(aa, str_remove(aa, ".*/") ))
getwd()

# get pmisc.R
source(sprintf("%s/PYH Important/PYH Statistics/PYH Using R/pmisc.R", str_extract(aa, ".*:")))

# options("scipen"= 100, digits = 3)  ## decimal places presented by print()
options("scipen"= 3, digits = 3)  ## 3 decimal places for digits, 3 decimal places for scientific notation

mtcars <- mtcars %>%  rownames_to_column(var = "carnames")   %>% mutate(gear = factor(gear))
mtcars.dd <- datadist(mtcars, adjto.cat = 'first' )
options(datadist="mtcars.dd")


# +++++++++++ Brackets --------------------------------------------------------

# Arguments --------------------------------------------------------
# using switch within brackets
# specify default values for optional args
funwrite1 <- function(file = NULL, 
                  pr = TRUE, 
                  na.rm=FALSE, 
                  nperm, 
                  pkg=c('foreign', 'haven'), ## + match.arg() to take "foreign" as default
                  dir='', 
                  fun = mean, 
                  mylist = list(),
                  datadensity=c('none','rug','hist','density'), 
                  frac=switch(datadensity,
                              none=NA,
                              rug=.03,
                              hist=.1,
                              density=.1), 
                  relax=if(missing(nonpo)) 'multinomial' else 'both',
                  nonpo  ## expect formula input
                  ) {
  
  if(! length(file))  # when file=NULL, do the following 
    if(!is.null(file))  # when fill is not NULL, do the following
      if(pr) cat('Running', file, '\n')
  if(na.rm) x <- x[! is.na(x)]  # no need to state = TRUE
  if(missing(nperm)) { xxx }
  if(missing(nperm) || is.na(nperm)) # missing OR non-missing object with NA element (double || needed)
  pkg <- match.arg(pkg)   if(pkg == 'foreign')  if (pkg != "haven")   #' match.arg() needed for if() to work
    if(dir != '') file <- paste(dir, file, sep='/')  # dir requires "string input"
  if (deparse(substitute(fun)) == "mean")  ## deparse(substitute(fun)) gives "mean"
    if (substitute(fun) == "mean")  ## applies to both "mean" and mean
      if (!is.function(fun)) stop("argument fun is not a function")
  if(length(mylist)) print("mylist is not empty")
  if (length(mylist) && is.null(names(mylist))) stop("mylist is supplied but not named")
  do.ppo <- relax != 'multinomial'  ## clever 
  if(do.ppo) if(! requireNamespace('VGAM', quietly=TRUE)) stop("This function requires the 'VGAM' package")
  mpo   <- relax == 'PO'
  data.frame(`Mean |difference| from PO` = if(mpo) NA else mean(abs(probs - probsPO)))
}  

#' isTRUE () and length() to detect (i) non-existent object or (ii) length > 1 
#' isTRUE requires logical x, equivalent to { is.logical(x) && length(x) == 1 && !is.na(x) && x }
aa <- integer(0)
isTRUE(aa)         # FALSE
length(aa) != 0    # FALSE
is.null(aa)        # FALSE

bb <- NA
missing(bb) ## bb is not missing but its value is missing
is.na(bb)   ## elements of bb are missing




# Arguments: Selection logic between args   --------------------------------------------------------------

## check selection logic of args options
## if ppc_fun arg contains "group", check (i) check that group arg cannot be NULL and (ii) group arg specifies valid  columns in data 
## if(var %in% names) vs  if(!var %in% names)
if ("group" %in% names(formals(ppc_fun))) {
  # check group is not NULL
  if (is.null(group)) {
    stop("Argument 'group' is required for ppc type '", type, "'.")
  }
  # check group is valid 
  if (!group %in% valid_vars) {
    stop("Variable '", group, "' could not be found in the data.")
  }
}

# ++++++++++++ Body------------------------------------------
# Validate: vector/dataframe checks: NAs probs  ------------------------------------------

mtcars["gear"]   ## data.frame
mtcars[c("gear", "vs")]  ; mtcars[, c("gear", "vs")] ## ditto data.frame
mtcars[["gear"]]; mtcars[,"gear"]; mtcars %>% pull(gear); mtcars %>% pluck("gear") ## returns vector

# create logical vectors and use them todynamically alter vector length and array dimensions
do.ppo <- relax != 'multinomial'   
do.mn <- relax == 'PO'
c('PO', 
  c('PPO', 'Multinomial')[c(do.ppo, do.mn)] )

array(NA, c(B, nrow(newdata), length(nam), do.ppo + do.mn),
      dimnames=list(NULL, NULL, nam,
                    c('PPO', 'Multinomial')[c(do.ppo, do.mn)]))


if (!requireNamespace("nnet", quietly = TRUE)) 
    stop("This function requires the 'nnet' package")
stop("must specify nonpo when relax is not \"multinomial\"")

if(!is.null(labeldf) & !(inherits(labeldf, 'data.frame'))){
  stop('labeldf must be a data.frame')
}

if(!any(class(x) %in% Cs(data.frame, character))) {
  stop('please supply a data.frame or character vector')
  stop (paste0('The object you supplied:' , deparse(substitute(data)), " is not a dataframe"))
  }

## remove NAs
p <- p[!is.na(p)]

newdata1 = eval(modblrm$call$data)[all.vars(modblrm$sformula)] 
newdata  = data.frame (newdata1)

if (anyNA(newdata)) {
  warning("NA responses in sample")
  newdata <- newdata[complete.cases(newdata), ]  ## remove NAs (if any)
}

## common vector/dataframe checks
if (abs(sum(p) - 1) > 0.00001) 
  stop("probabilities in p do not add up to 1")

is.binary <- function(v) {
  x <- unique(v)
  x <- x[!is.na(x)]
  length(x) - sum(is.na(x)) == 2L
  ## all( x %in% 0:1) ## must be 0 or 1
  
}

if ( (nsam%%2) != 0 ) stop ("nsam must be an even integer")


mfoo <- function(x, data, ...) {
  ## x is a formula 
  ## na.omit targets whole dataframe  
  ## data[complete.cases(data[,1]), ]  ## can target specific vars
  
  cs <- all.vars(x)
  data <- na.omit(data[, cs])
  
  return(data)
}


#' check and ensure data columns are of a given class (Say, character)
#' vapply: similar to sapply() but it further specifies output class 
myvars <- mtcars[1:4] %>% names
not_character <- vapply(mtcars[myvars], function(x) !inherits(x, "character"), TRUE)
mtcars[, myvars[not_character]] <- lapply(mtcars[, myvars[not_character]] , as.character)




# Validate: regression models  ------------------------------------------
if(!any(class(rmsObj) %in% Cs(rms))) {
  stop('rmsObj must be an rms model fit')
}

predvar_valid = modblrm$Design$name  
if(!predvar %in% predvar_valid){
  stop(predvar, " is not found in the model. ", 
       "Available predictors are:\n", str_flatten(predvar_valid, " , ")) # paste(predvar_valid, collapse = " , ")
  }


## predictor settings (categorical/factor vs continuous)
varquant1 = newdata %>% datadist() %>% pluck(1, predvar) 
varquant <- if(is.vector(varquant1))
  varquant1 %>% .[c(1,3)] else 
    varquant1 %>% .[c(4,5)]


# Validate: ggplot fun  ------------------------------------------
# is.theme()
# https://github.com/paul-buerkner/brms/blob/master/R/conditional_effects.R


# Fn args: match.call()  -------------------------------------------------------------
#' match.call() returns `call` object with elements comprising all supplied args, including  dotargs   
#' call object: first element is a quoted command/fn, other elements are a list of args for the command/fn 
#' modify first element (match.call[[1]]) to create a yet-to-be-evaluated function
#' consolidate dotargs using list(), substitute(list(...)), or match.call()

foo <- function(abc=NULL, ...) {
  list(...) %>% print # captures dot args
  mf <- match.call()  # default expand.dots=TRUE expands ... to include dotargs
  print(mf)
  return(mf)
}
mc <- foo(abc=1, x=2, wombie=c(3,4)) ## match.call() includes abc and ...
mc %>% str; class(mc)
for(i in 1:4) print(mc[[i]])
names(mc)



#' match.call() to isolate function args 
cubesfun <- function(a, b, c, d, wombie){
  cubes <- a + b + c + d + wombie
  return(cubes)}

halim <- function(a, b, ...){
  
  #' match(Cs(a, b, c, d), Cs(a, b, d, a, f, g, b), OL) # index vec1 onto vec2 (where in vec2 can vec1 be found).. OL if absent
  #' setdiff(Cs(a, b, c, d), Cs(a, b, d, f, g))  # vec1 - vect2 (what's left in vec1 after removing common elements)
  
  dots <- list(...)
  cf <- match.call(expand.dots = TRUE)
  cfnames <- formals(cubesfun) %>% names
  keepers <- match(cfnames, names(cf), 0L)  ## index cfnames onto cf (where in cf could cfnames be found?) 
  cf <- cf[c(1L, keepers)]                  ## ensure cf contains ONLY cubesfun args
  cf$d <- 5                                 ## include arg d in cf
  cf[[1L]] <- quote(cubesfun)
  
  #' remove cubesfun args from dots
  #' no need to setdiff or match; missing names will be ignored
  for (i in cfnames) dots[i] <- NULL   ## remove args from dots
  
  cf <- eval(cf, parent.frame()) ## evaluate within halim()
  return(cf)
  
  }

halim(a=1, b=2, c=3, wombie=4, chawang=100)

dots <- list(c=3, wombie=4, chawang=100)
cfnames <- formals(cubesfun) %>% names
for (i in cfnames) dots[[i]] <- NULL   ## remove args from dots; no need setdiff or match


#' modify match.call()[[1]] to create R function (example 1)
aa <- function(formula, data, ...)  match.call(expand.dots = TRUE) %>% return
mf <- aa(formula = hp~drat, data=mtcars)
mf[[1]] <- quote(model.frame)  # modify [[1]] to create yet-to-be-eval stats::model.frame() fun
mf %>% class # call
eval(mf)  ## evaluate model.frame


#' modify match.call()[[1]] to create a function (example 2)
#' cl[[1]] <- quote(function_name)  ## creates a function
#' eval call outside the foo function (into the parent or grandparent environment)

FOO <- function(x) 1000 * x
y <- 1
foo <- function(...) {
  
  print("   match.call")
  match.call() %>% print
  print("       match.call + expand.dots \n")
  match.call(expand.dots = TRUE) %>% print
  print("        list(...)\n")
  list(...) %>% print
  print("      match call and list")
  as.list(match.call()) %>% print
  print("    substitute")
  substitute(list(...)) %>% print
  y = 2
  cl <- match.call()
  cl[[1]] <- quote(FOO)  ## modify cl to become FOO()
  message("evaluate it locally")
  eval(cl) %>% print
  message("evaluate it in the parent environment")
  eval(cl, parent.frame(2)) %>% print
  invisible(NULL)
}
foo(y)



# Dot args: list() Extract, check, merge dot args  --------------------------------------------------
## gathering ppc_args (from dots and other sources) to feed into ppc_fun via do.call
dots = list(...)  ## capture

# vector_AAA %in% BBB  ## returns T/F vector with length of AAA
if (!"threshold_val" %in% names(dots) ) {
  dots$threshold_val <- c(0,1)
}

# identify and warn about arg typos   
valid_args <- names(dots) %in% names(formals(my_good_function))  ## formals() gives funargs 
if(length(dots[!valid_args])){
  warning(
    dots[!valid_args] %>% names, " :not valid arg(s) for my_good_function \n", 
    "Available args: ", str_flatten(names(formals(my_good_function)), " , "))
}


#' extract relevant dotargs for a given function  
#' Merge dotargs with non dot-args using modifyList() or c(list, vector)
#' modfiyList(lista, listb) - coalesce ("left_join" + full-join) lists a and b
#' c() vs list()
c(mtcars) ## returns a list with "multiple" arguments, c() to separate "mtcars" args
c(list(mtcars))  ## keep mtcars as one arg

dots[valid_args] ## extract relevant dotargs

goodfun_args <- c(
  list(y, yrep),   ## use list() to make y(vector) a single arg, yrep (matrix) a single arg  
  dots[valid_args])  ## use c() to split/separate dots args


goodfun_args <- c(
  list(contobj = mycontobj),  ## keep as single argument
  myvar = predvar,    ## predvar is a single-element vector
  dots[dots_args])  ## using c() to separate dots arg


#' dot management
#' myfun uses myfun1 and myfun2
#' in dots(), extract those for myfun1 and those for myfun2
#' myfun1 additionally has myiv arg 

myfun1 <- function(myiv=10, mfarg1, mfarg2) print("hello")
myfun2 <- function(mfarg3) print("hi")

myfun <- function(myiv = 1, ...){
  
  # capture the dots
  dots <- list(...)
  dotnames <- names(dots)
  
  # myfun1 args names
  myfun1_arg <- names(formals(myfun1))
  myfun1_params = list(myiv=myiv)  ## non-dots args
  
  if (length(dotnames[myfun1_arg]) > 0) {
    #' dots contain myfun1 args
    #' update myfun1_params using modifyList() 
    #' once done, remove from dots(), myfun1 args 
    #' dots() can now be applied to myfun2
    myfun1_params <- modifyList(myfun1_params, dots[myfun1_arg]) #[] = list [[]] = vector
    dots[myfun1_arg] <- NULL
  }
  
  return(myfun1_params)
  
}

myfun2(mfarg1=10, mfarg2=20, wombie=3) 

# Dot args: substitute(list(...)) --------------------------------------------------
#' substitute(list(...)) convert list(...) to a yet-to-be-evaluated call object
#' similar to match.call() but match.call() will extract all args 
#' rms:::rmsArgs creates a list from call object 


#' substitute() expects a, b args  ...
#' better:  function (a, ..., b=4)
myfoo <- function(a, b=4, ...) {
  #' function (a, ..., b=4) is a better approach
  factors1       <- substitute(list(...))
  return(list(factors1, b))
}

myfoo1 <- function(a, ..., b=4) {
  #' function (a, ..., b=4) is a better approach
  factors1       <- substitute(list(...))
  return(list(factors1, b))
}

myfoo(a=6, b=10, dotarg1, dotarg2=c(2,2)  )
myfoo(a=6, dotarg1, dotarg2=c(2,2)  )  ## dotarg1 missing
myfoo1(a=6, b=10, dotarg1 , dotarg2=c(2,2)  )
myfoo1(a=6, dotarg1 , dotarg2=c(2,2)  )  ## dotarg1 not missing




.object <- substitute(list(wombie_cubes=c(10,12), chawang_cubes= 0, akow))
.object; class(.object); str(.object) 
for(i in 1:4) print(.object[[i]])
for(i in 1:4) class(.object[[i]]) %>% print
length(.object) # number of elements + 1 
names(.object)  # = within ... generates names, otherwise "" (but not NA)
length(names(.object)) # number of elements + 1 (akow = "")
#' sapply() converts call to a list (amazing!)
#' however akow=L2 element, and L2 elements for wombie includes "c"
.vars <- sapply(.object, as.character)[-1] 
rms:::rmsArgs(.object) %>% class

rmsArgs <- function (
    ## convert call object to a list
    .object, ## call object to be evaluated
    envir = parent.frame(2)) {
  
  if (length(.object) < 2) return(NULL)  ## empty list
  .names <- names(.object)[-1]
  if (!length(.names)) 
    .names <- rep("", length(.object) - 1) # create empty names vector
  .n <- length(.names)  ## number of elements
  .vars <- sapply(.object, as.character)[-1] # convert call object to a list
  .res <- vector("list", .n)  # creates empty list
  for (.i in 1:.n) {
    if (.names[.i] == "") {
      .names[.i] <- .vars[.i]   ## if empty, grab names from L2 elements of .vars (clever)
      .res[[.i]] <- NA          ## replace L2 .res element with NA
    }
    else .res[[.i]] <- eval(.object[[.i + 1]], envir = envir) ## evaluate L2 elements with "call" class
  }
  names(.res) <- .names
  .res
}


# Dot args: do.call() + dot args  --------------------------------------------------
# do.call(fun, named list)  ## named list: (i) list names = arg names (ii) list values = arg values
janitor_args <- list(dat=mtcars, case = "title")
do.call(clean_names, janitor_args) %>% head

# do.call() allows you to call a fun using character vector
fun_a <- partial(summary)
fun_b <- partial(describe)
map(letters[1:2], ~ do.call (str_glue("fun_{.}"), list(mtcars)))

## calling functions of another package
ppc_fun <- get(paste0("ppc_", type), asNamespace("bayesplot")) ## calling function from bayesplot


dots <- list(...)
valid_args <- names(dots) %in% names(formals(my_good_function))  ## formals() gives funargs 

goodfun_args <- c(
  list(y, yrep),   ## use list() to make y(vector) a single arg, yrep (matrix) a single arg  
  dots[valid_args])  ## use c() to split/separate dots args

if (!is.null(group)) goodfun_args$group <- newdata[[group]]
do.call (my_good_function, goodfun_args)

# do.call() allows you to call a fun using character vector
fun_a <- partial(summary)
fun_b <- partial(describe)
map(letters[1:2], ~ do.call (str_glue("fun_{.}"), list(mtcars)))



 
# Regression: predict()   --------------------------------------------------
myformula <- gear ~ vs + wt  

#' matrix allows for subtraction
f <- lrm (myformula, data  = mtcars )
a <- predict(f, newdata = data.frame(vs = 1, wt = 2.5), type = "fitted.ind") # numeric vector
if(nrow(newdata) == 1) a <- matrix(a, nrow=1)  ## matrix so that colnames() will work  

#' if we were to subtract two 3x 5 matrices repeatedly in a bootstrap loop
#' should create array[B, 3, 5]




# Formulae: terms() model.frame() modify   --------------------------------------------------

# formula arg for variable
funtest1 <- function (myvar){
  # myvar is a formula arg 
  myvar <- as.character(myvar)[-1]
  return(myvar)
}
funtest1 (myvar = ~ gear)



#' reformulate() + update(formula, string) 
#' create/update formula using character vectors
treatment <- "am"
QALYs <- "hp"
costs <- "cyl"
cluster <- "gear"
covars <- c("mpg","rcs(cyl,3)", "mo(wt)")
f <- reformulate(c("treatment", covars), "QALYs")
fixed <- list(QALYs = stats::reformulate(c(treatment, covars), QALYs),
              Costs = stats::reformulate(c(treatment, covars), costs))
random <- sprintf( " . ~ . + (1 | %s)", cluster)
update( fixed[[1]], random)
fixed <- lapply(fixed, function(f) stats::update(f, random))
brms::mvbrmsformula(flist = fixed, rescor = FALSE)
update(f, str_glue(". ~ . +   {cluster}"))
update(f, ". ~ . + quote_also_can")



mformula <- hp ~ drat + cyl
mformula1 <- hp ~ drat + rcs(cyl,3)
var_add <- ~ rcs(wt,3) + vs
as.character(var_add)[-1]       ## remove ~ (more elegant!)
gsub( "~", "", format(var_add)) ## remove ~
update(mformula, paste("~ . +",  as.character(var_add)[-1])  )
update(mformula, paste("~ . +",  gsub( "~", "", format(var_add))  ))
all.vars(mformula1)
as.character (mformula)
as.character(mformula)[-1]
attr(terms(mformula1), "term.labels") 
mt <- terms(mformula, data = mtcars); mt
str(mt) ## inspect attributes of terms()
if (attr(mt, "response") == 0L) stop("response variable is required")
attr(mt, "variables") %>% class
attr(mt, "term.labels") ## character predictors
model.frame(mformula, data=mtcars) 
mymod <- ols(mformula, data=mtcars)
model.frame(mymod, data=mtcars) 



form_foo <- function(formula, data, ...){
  # create a 2-var data.frame using model.frame()  
  
  #' ensure valid formula object (1iv and 1dv)
  if (missing(formula) || (length(formula) != 3L))
    stop("form_foo requires a two sided formula")

  mt <- terms(formula, data = data)
  if (attr(mt, "response") == 0L) stop("response variable is required")
  
  #' ensure mf contains only model.frame args
  mf <- match.call(expand.dots = TRUE)
  mfnames <- c("formula", "data")  ## args of model.frame
  keepers <- match(mfnames, names(mf), 0L)
  mf <- mf[c(1L, keepers)]

  mf[[1L]] <- quote(stats::model.frame)  # quote() to convert call to a function 
  mf <- eval(mf, parent.frame())
  return(mf)
  }

form_foo(formula = hp~drat, data=mtcars)


#' modify formula using do.call + substitute 
#' setNames() to allow separate original and replacement vars
#' setNames() expects 2 vectors/list: the element is the replacement value; the new name is the original var 
myform <- dv | koosvar ~ weight +  age
dd = "flex"
do.call(substitute, list(myform, list(dv= as.symbol(dd), koosvar = as.symbol("dstairs") ))) ## single 
do.call(substitute, list(myform, 
                         setNames(list(as.symbol(dd), as.symbol("dstairs")), c("dv", "koosvar")))) ## multiple 

yhmodform <- function(myformula, 
                      orivar,  ## original var 
                      repvar) {
                        
  # do.call(substitute, list(myformula, 
  #                          setNames(list(as.symbol(repvar) ), orivar ))) %>% formula  ## single var
  
  do.call(substitute, list(myformula, 
                           setNames(map(repvar, as.name), orivar ))) %>% formula
                        }
yhmodform(myformula = myform, c("dv", "koosvar"), repvar=c("superdv", "supersuper"))

newformula <- hp ~ cyl + rcs(wt, 3)
cat("My formula takes the form", format(newformula), "\n")


#' modify formula using deparse, stringr, as.formula 
form_cov <- blah ~  blah_base + tgroup * time_24
bf_builder <- function(myform, dv){
  #' bf_builder(form_cov, dv="fgs")
  myform_updated <- str_replace_all(myform %>% deparse, "blah", dv) %>% as.formula 
  return(bf(myform_updated, sigma_cov))
}

# Operators and Replacement fun   -----------------------------------------------------------------
## creating pipe operator (bayesian folder, s1 supplementary thesis)
`%between%` <- function(x, y) x >= y[1] & x <= y[2]   # logical check for betweenness

# replacement function to update vectors 
# 'FUN<-' <- function (x, value) {output to return to x}
# `value` args must be present in the replacement fun
# FUN(obj) <- value
# R passes obj and value  into "FUN<-"() and assigns output back to obj 
# obj <- "FUN<-"(obj, value) ditto
'myfun<-' <- function (x,value)   paste0(value, " says hello")
my_x = numeric(0)
myfun(my_x) <- "This wombat" ## equivalent to x <- 'myfun<-'(x, myy)
my_x

## default list
.theme_args <- list(
  legend.position= c(0.1,0.1), 
  plot.title = element_text(face = "bold"))
# do.call(theme, .theme_args)
.theme_args

## list of updated args
## bigfun <- function (theme_args = list(), ...) {blah}
theme_args <- list(legend.position= c(0.88,0.88), 
                   plot.caption = element_text(face = "italic"))

## replacement function to update default .theme_args with theme_args

'replace_args<-' <- function(x, dont_replace = NULL, value) {
  value_name <- deparse(substitute(value))
  value <- as.list(value)
  if (length(value) && is.null(names(value))) {
    stop("Argument '", value_name, "' must be named.")
  }
  invalid <- names(value)[names(value) %in% dont_replace]
  if (length(invalid)) {
    # invalid <- collapse_comma(invalid)
    stop("Argument(s) ", invalid, " cannot be replaced.")
  }
  x[names(value)] <- value
  x
}

replace_args(.theme_args) <- theme_args
# replace_args(.theme_args, "legend.position") <- theme_args
.theme_args


# arrays  -----------------------------------------------------------------

## 3-d arrays
#' https://stackoverflow.com/questions/23302072/use-apply-on-a-multi-dimension-array
#' https://stackoverflow.com/questions/64671833/using-apply-on-multidimensional-array-in-r
#' apply(myarray, c(1,2), sum); appply (array, margins, function)
#' margin = axis or dimension
#' Start with a 2-D surface defined by the rows and columns c(1,2) of a 3-D block. 
#' Move 2-D surface surface along the remaining axis (3) (that does not form the surface)
#' output has the same dimension as 1,2 = row-column
 

matrix(NA, 2, 3)  ## 2-d array
myarray <- array(NA, c(4000,32,22)); myarray
B <- array (1:27, c(3,3,3)); B
B <- array(1:24, dim = 2:4); B
## aperm() to fill values row-wise
array(1:24,c(3,4,2))  ## values filled column-wise
aperm(array(1:24,c(3,4,2)), c(2,1,3))
apply(B, 1, sum)
apply(B, 2, sum)
apply(B, 3, sum)       ## sum all values on the frontal 2-D, then move into page
apply(B, c(1,2), sum)  ## frontal/vertical 2D surface moving into page
apply(B, c(2,1), sum)  ## as above, then rotate clockwise 90
apply(B, c(2,3), sum)  ## transverse/horizontal 2D surface moving downward
apply(B, c(1,3), sum)  


#' if rows were bootstrap iterations
#' c(2,3)    move horizontal 2-D surface downward - summarize over bootstrap iterations
#' c(2,3,4)  c(2,3) group_by 4th dimension (PPO/Multinomial)
cl <- function(x) {
  qu <- unname(quantile(x, c(0.025, 0.975)))
  c(Lower=qu[1], Upper=qu[2]) 
}
## 10x2 surface, 4 layers, 2 groups
B <- array(1:80, dim = c(10, 2, 4, 2), 
           dimnames = list(NULL, NULL, c(1:4),  c('PPO', 'Multinomial') )); B
apply(B, 2:3, sum)  ## x-Z surface, moving downward
apply(B, 2:4, sum)  ## group_by, x-Z surface, moving downward
apply(B, 2:4, cl)

B[1,,,"PPO"]  ## first X-Z surface of PPO group
B[,1,,"PPO"]  ## first Y-Z surface of PPO group
B[1,,,"PPO"] <- matrix(NA, 2, 4)


## customize fun for arrays
ppdf <- predict(hormb, type="fitted.ind", posterior.summary = "all") 
ylev <- hormb$ylevels
apply(ppdf, c(1,2), function (x) sum( ylev * x))  ## get conditional mean!
apply(ppdf, c(1,2), function (x) rbinom(1,1,x))

## cutomized fun returns a list ()
## rmultinom() returns vector 
## apply(ppdf, c(1,2), function (x) rmultinom(1,1,x), simplify=FALSE) ## each elemnt is a list
apply(ppdf, c(1,2), function (x) {
  myvec = unlist(rmultinom(1,1,x))  ## need to unlist output
  myvec_names = ylev
  return(myvec_names[myvec==1])
}) %>% 
  apply(c(1,2), as.numeric) 

## for-loop + fun + arrays 
## slow! may have a better way
for (i in 1:6) 
  for (j in 1:4000) {
    pred_ordinal[j,i, ] <- pomodm(p = pred_ordinal[ j,i, ], odds.ratio = or_matrix[j,i]  )
  }


# approx() outer() uniroot()---------------------------------------------------------
## x= (5,6) , y=c(10,20)
approx(c(5,6), c(10,20),  xout=5.45, f=0, method="constant")$y  ## step function, f=0 (y LHS), f= 1 (y RHS)
approx(c(5,6), c(10,20),  xout=5.45, method="linear")$y  ## linear interpolation (default)
approx(c(5,6), c(10,20),  xout=6.1, rule=2)$y     ## largest y value when xout exceeds x
approx(c(5,6), c(10,20),  xout=c(5,5.4,5.8), method="linear")$y  ## linear interpolation (default)

# outer(row_vector, column_vector, operation in each cell combining rows and columns)
# CPM: outer(alpha, XB, "+")
outer(c(1,2,3), c(10,20), "+")


# Using uniroot function
# Outer fun: contains arguments that can go to inner function, exclude the argument that we are solving (m in this case)
# Inner fun: contains the argument that we are solving; output is the value that we want to minimize
# uniroot: wraps inner fun, interval = argument that we are solving (m), must include value for all formals listed in inner fun
m <- function(n,         ## sample size
              ybar,      ## sample mean
              sigma,     ## pop SD 
              mu0=150,   ## prior mean
              sigma0=50, ## prior variance of mean
              cutoff=110) {
  
  
  ## inner function (solve for m that minimizes value of interest)
  ## argument list includes n since interval in uniroot() uses n
  calc <- function(n, m) {
    vpost1 <- 1 / ((1 / (sigma0^2)) + 1 / ((sigma^2) / n))
    mupost1 <- mu0 * vpost1 / (sigma0 ^ 2) + ybar * vpost1 / ((sigma ^ 2) / n)
    vpost2 <- (sigma ^ 2) / m
    (cutoff - mupost1) / sqrt(vpost1) - (cutoff - ybar) / sqrt(vpost2)  ## value to minimize
  }
  
  
  ## uniroot() include value for n, interval for m
  round(uniroot(calc, 
                interval=c(n / 2, 2 * n), 
                n=n)$root, 1)
  
}
m(8, 100, 10, sigma0=500000)


# misc: consolidation, printing -----------------------------------------------------------
# Consolidate test results
structure( 
  list(utest        = if(!is.null(m2)) c(rr, pval = concord_p),
       concord_pval = if(!is.null(m2)) concord_p,
       ltest        = ltest,
       rev          = rev))

structure(list(estimates=z, 
               stats=stats, 
               mad=mad, 
               newdata=newdata,
               nboot=nboot, boot=if(B > 0) boot),
          class='impactPO')



mypets = c("wombie", "jerry", "chawang")
cat("PMC pets are", mypets, "\n") # best method
print(paste("PMC pets are", mypets))
print(paste(c("PMC pets are: ", mypets), collapse=" "))
str_glue("PMC pets are {str_flatten(mypets, collapse=' ')} ")




# ifelse (and others) Gotchas -----------------------------------------------------------------

#' && vs &
#' Difference is not just about speed from short-circuiting
#' is.numeric(var) && var(variable) == 0 ,   var() will run only when is.numeric() is TRUE
#' is.numeric(var) &  var(variable) == 0  ,  will balk when var() is forced to run on non-numeric vectors


myvector = c(NA,2,3,4)
any(myvector>1)  ## TRUE as available values satisfy condition
any(myvector>5)  ## NA 
any(myvector>5, na.rm=TRUE)  ## FALSE

ifelse(FALSE, 1, c(2, 3)) ## returns 2 and not c(2,3)
if(FALSE) 1 else c(2,3)   ## returns c(2,3)
ifelse(c(FALSE,FALSE), 1, c(2, 3)) ## returns c(2,3)

# if_else for dates
blah %>% mutate(axdate = if_else(ptid=="HUATR100" & axdate=="2021-11-19", ymd("2021-11-12"), axdate)) 

mtcars %>% dplyr::select(am, hp) %>% arrange(am) %>% 
  mutate(hp = yhmakemiss(hp, 0.4)) %>% 
  ## amongst am=1, convert to 0 only when hp<100, retain 1 if hp is missing 
  mutate(am2 = ifelse( am==1 & 
                         (!is.na(hp) & hp<100), 0, am))

aa <- mtcars %>%  rownames_to_column(var = "cname") %>% dplyr::select(1:4) %>% tibble
aa %>% 
  mutate(mpg_new = ifelse(
    grepl("^(m)" , cname, ignore.case=TRUE), mpg, NA))

# R package functions Creation ++++++++++++++ -----------------------------------------------------------------
ls("package:huatR")  ## list functions of a package
getAnywhere(pp_check.blrm)
huatR:::pp_check.blrm(hormb) ## ::: to get unexported package functions
devtools::install_github("harrelfe/rms", force = TRUE)

# Step 0: Installation ------------------------------------------------------------
#' install Git https://git-scm.com/download/win
#' install Git Desktop

# Step 1: Create New Project ----------------------------------------------
#' File --> New Project ==> R Package --> Give Package Name and Check "Create a Git Repo"
#' Console: usethis() to specify packages in DESCRIPTION
#' Remove NAMESPACE (in prep for devtools::document() in Step 2)
#' Remove default hello.R function
usethis::use_mit_license()
usethis::use_package("dplyr")
usethis::use_package("purrr")
usethis::use_package("readr")
usethis::use_package("rms")



# Step 2: Write, Docu, and Test Functions ----------------------------------------------
#' Assume our R package is called `carefoo`
#' In R folder, create R script files
#' Within body of the R function, ctrl + shift + alt + R to invoke roxygen comments
#' @ export: removing this will hide function
#' devtools::document(): creates Rd files + NAMESPACE
#' @ examples: delete if no examples are given (else check() will throw errors)
#' Comments within function should use # and not #'
devtools::document() # ensure hello.Rd is deleted/not created
usethis::use_pipe()  # do this after document()

#' Test function using usethis::use_testthat
usethis::use_testthat() ## create test folder

# Step 2.1: Include data-sets  ----------------------------------------------
toydf <- mtcars [1:5, 1:4]
usethis::use_data(toydf)
carefoo::toydf # `carefoo` is our package


# Step 2.2: Change Package Name  ----------------------------------------------
#' update the .RProj name
#' update the folder name
#' modify DESCRIPTION, LICENSE

# Step 3: Check Build Package  ----------------------------------------------
#' check before package building
#' Build creates tar.gz files
#' tools --> install packages --> install from tar.gz files
devtools::check()
devtools::build() # create tar.gz files

# Step 4: Upload on Github  ----------------------------------------------
#' gitbash method balks becos inability to authenticate
#'
#'
#' Github Desktop method
#' Github desktop: File --> Add local repository (direct Github desktop to `carefoo` folder)
#' Repository --> repos --> repos setting  --> give name of package and push to remote  
#' 
#' Github Desktop method (old)
#' Repo - Setting --> To delete
#' Repo - New  -> Ensure repo shares same name as R package (`carefoo`)
#' https://github.com/yhpua/carefoo.git (git directory would be generated)
#' Github desktop: File --> Add local repository (Or drag folder into Github desktop)
#' Repository --> repos --> repos setting  --> https://github.com/yhpua/pkg.pyh.git
#' Gotcha: Github Desktop method
#' If the above fails (not sure why.. unstable)
#' Repository --> repos --> repos setting: give an arbitrary name
#' This creates a remote github repo under the arbitrary name!
#' delete everything on github and restart process


# Step 5: Version Control  ----------------------------------------------
#' On Rstudio
#' After making changes: Tools - Version Control - Commit  (Control-Alt-M)
#' Click LHS small box for "Staged", add comments, and click "Commit"
#' On Github Desktop
#' Fetch Origin tab - this will update remote Github repo
devtools::install_github("yhpua/huatR", force = TRUE)
ls(getNamespace("huatR"), all.names=TRUE)  #list all functions of a package
data(package = c("huatR"))                 # list datasets in packages
carefoo::toydf 

## Reverting to previous commits (Rstudio)
#' New changes are yet to be committed, Tools - Version ctrl - choose file and "Discard all"  
#' New changes have been committed, Tools - Version ctrl - History - "View File" button -> 
#' "Save As" to override and revert to old file --> save and commit changes
#' 
#' 
## Reverting to previous commits (Git bash)
#' in the folder, right click mouse -> "Git bash here"
git status
git log –oneline
git revert 794fb48 ## SHA number


# Step 5.5: Create a Git repo (Non package)  ----------------------------------------------
#' Git repo doesn't need to be a package
#' Rstudio: File --> New Project -> check "create a git repo"
#' Generate contents and drag created folder to Github desktop 
#' Initial commits - Can select files to be excluded from remote Github)
#' Use Github Desktop to push local repo to Github remote repo
#' 
#' 
#' #' ## Section 5.5.1a (to create URL for a single html page) Method 1
#' https://quarto.org/docs/publishing/github-pages.html
#' New Project --> git repo --> generate contents --> Github Desktop to create remote repo
#' Remote Github: Settings --> Pages (LHS) --> Build and Deployment::Source --> Branch
#' Jan 2023: Ensure Branch(master), similar to Section 5.5.1b before changing to gh-pages (else files will be deleted when we create gh-pages) 
#' To change to Branch(gh-pages), Rstudio terminal shift-insert the following
git checkout --orphan gh-pages
git reset --hard
git commit --allow-empty -m "Initialising gh-pages branch"
git push origin gh-pages
#' Once done, ensure Github Desktop is closed
#' Rstudio terminal: shift-insert -->  quarto publish gh-pages --no-render mydocu.qmd
#' To update qmd file:  quarto publish gh-pages mydocu.qmd
#' 
#' 
#' #' ## Section 5.5.1b (to create URL for a single html page) Method 2
#' Remote Github: Settings --> Pages (LHS) --> Build and Deployment::Source --> "Deploy from Branch"
#' Branch --> Select "Master" (Wait for page to refresh, ay need to step out of folder)
#' CON: Using this method, Github publishes only the index.html file  
#' 
#' 
# Step 6: Collaboration  ----------------------------------------------
#' Github Desk-stop
#' File - Clone Repo - URL  - paste https://github.com/pauljohn32/rockchalk 
#' Select a folder in your laptop to save the local repo
#' Comments: Type "Initial Commits"
#' Github Desktop will prompt us to "create a fork"
#' Push Origin (this will fork the repo to our remote Github)
#' 
#' Rstudio
#' File --> New Project --> Existing Directory --> Direct Rstudio to package-of-interest
#' Make the changes and commit changes on Rstudio
#' Return to Github Deskstop --> Push Origin 
#' On remote Github repo --> Contribute --> "Open Pull request"



